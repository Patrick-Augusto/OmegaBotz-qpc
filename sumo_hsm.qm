<?xml version="1.0" encoding="UTF-8"?>
<model version="5.2.1" links="1">
 <!--${qpc}-->
 <framework name="qpc"/>
 <!--${AOs}-->
 <package name="AOs" stereotype="0x02">
  <!--${AOs::SumoHSM}-->
  <class name="SumoHSM" superclass="qpc::QActive">
   <!--${AOs::SumoHSM::timeEvt}-->
   <attribute name="timeEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::buzzerTimeEvt}-->
   <attribute name="buzzerTimeEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::buzzerCount}-->
   <attribute name="buzzerCount" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::strategy}-->
   <attribute name="strategy" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::timeEvt_2}-->
   <attribute name="timeEvt_2" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::calib_time_1}-->
   <attribute name="calib_time_1" type="uint32_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::calib_time_2}-->
   <attribute name="calib_time_2" type="uint32_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::calib_status}-->
   <attribute name="calib_status" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::turn_180_time_ms}-->
   <attribute name="turn_180_time_ms" type="uint16_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::star_velocity}-->
   <attribute name="star_velocity" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::SM}-->
   <statechart properties="0x03">
    <!--${AOs::SumoHSM::SM::initial}-->
    <initial target="../1">
     <action>(void)par; /* unused parameter */
/* arm the private time event to expire in 1/2s
* and periodically every 1/2 second
*/
QTimeEvt_armX(&amp;me-&gt;buzzerTimeEvt, BSP_TICKS_PER_SEC/10, 0);

me-&gt;buzzerCount = 0U;</action>
     <initial_glyph conn="72,7,5,1,21,6,-8">
      <action box="0,-2,7,2"/>
     </initial_glyph>
    </initial>
    <!--${AOs::SumoHSM::SM::Idle}-->
    <state name="Idle">
     <entry>BSP_ledOff();
BSP_motors(0,0);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_SEC/2, BSP_TICKS_PER_SEC/2);</entry>
     <exit>QTimeEvt_disarm(&amp;me-&gt;timeEvt);
QTimeEvt_disarm(&amp;me-&gt;buzzerTimeEvt);</exit>
     <!--${AOs::SumoHSM::SM::Idle::TIMEOUT}-->
     <tran trig="TIMEOUT">
      <action>BSP_ledToggle();</action>
      <tran_glyph conn="42,30,3,-1,14">
       <action box="0,-2,14,4"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::Idle::START_RC}-->
     <tran trig="START_RC" target="../../2">
      <tran_glyph conn="85,40,1,0,45,10">
       <action box="4,-3,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::Idle::START_AUTO}-->
     <tran trig="START_AUTO" target="../../4">
      <tran_glyph conn="42,41,3,3,-19,11,3">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::Idle::PLAY_BUZZER}-->
     <tran trig="PLAY_BUZZER">
      <action>BSP_ledStrip(me-&gt;buzzerCount, 1);
BSP_buzzer_beep();

if (me-&gt;buzzerCount == 16) {
    QTimeEvt_armX(&amp;me-&gt;buzzerTimeEvt, 1.6 * BSP_TICKS_PER_SEC, 0);
} else if (me-&gt;buzzerCount &lt; 16){
    QTimeEvt_armX(&amp;me-&gt;buzzerTimeEvt, BSP_TICKS_PER_SEC/10, 0);
}


me-&gt;buzzerCount += 1;</action>
      <tran_glyph conn="42,34,3,-1,14">
       <action box="0,-2,12,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::Idle::START_CALIB}-->
     <tran trig="START_CALIB" target="../../8">
      <tran_glyph conn="85,25,1,0,133,12">
       <action box="4,-2,13,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="42,11,43,33">
      <entry box="1,2,24,6"/>
      <exit box="1,8,38,7"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::RCWait}-->
    <state name="RCWait">
     <entry>BSP_startRC();
BSP_ledOff();</entry>
     <!--${AOs::SumoHSM::SM::RCWait::RADIO_DATA}-->
     <tran trig="RADIO_DATA">
      <tran_glyph conn="118,60,3,-1,11">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::RCWait::GO_TO_IDLE}-->
     <tran trig="GO_TO_IDLE" target="../../1">
      <tran_glyph conn="134,50,0,1,-14,-49">
       <action box="-45,-17,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="118,50,20,15">
      <entry box="1,2,12,4"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::StarStrategy}-->
    <state name="StarStrategy">
     <entry>BSP_motors(me-&gt;star_velocity, me-&gt;star_velocity);</entry>
     <!--${AOs::SumoHSM::SM::StarStrategy::LINE_DETECTED}-->
     <tran trig="LINE_DETECTED" target="../../6">
      <tran_glyph conn="24,80,3,3,-1,31,16">
       <action box="0,-2,15,3"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StarStrategy::STOP_AUTO}-->
     <tran trig="STOP_AUTO" target="../../4">
      <tran_glyph conn="41,69,0,2,-8">
       <action box="1,-6,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StarStrategy::DIST_SENSOR_CHANGE}-->
     <tran trig="DIST_SENSOR_CHANGE">
      <action brief="CheckSensors">int sensors_on = BSP_Check_Dist();

switch(sensors_on){
    case 0:
        BSP_motors(60, 60);
        break;
    case 1:
        BSP_motors(80,-80);
        break;
    case 2:
        BSP_motors(80,0);
        break;
    case 3:
        BSP_motors(100,100);
        break;
    case 4:
        BSP_motors(0,80);
        break;
    case 5:
        BSP_motors(-80,80);
        break;
}
</action>
      <tran_glyph conn="24,83,3,-1,12">
       <action box="0,-2,22,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="24,69,24,28">
      <entry box="1,2,23,6"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::AutoWait}-->
    <state name="AutoWait">
     <entry>BSP_motors(0,0);
BSP_ledOn();</entry>
     <!--${AOs::SumoHSM::SM::AutoWait::START_AUTO}-->
     <tran trig="START_AUTO">
      <!--${AOs::SumoHSM::SM::AutoWait::START_AUTO::[strategy_0]}-->
      <choice target="../../../3">
       <guard brief="strategy_0">me-&gt;strategy == 0</guard>
       <choice_glyph conn="38,58,4,0,11">
        <action box="-9,5,9,4"/>
       </choice_glyph>
      </choice>
      <!--${AOs::SumoHSM::SM::AutoWait::START_AUTO::[strategy_1]}-->
      <choice target="../../../5">
       <guard brief="strategy_1">me-&gt;strategy == 1</guard>
       <choice_glyph conn="38,58,5,0,29,11">
        <action box="20,5,11,3"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="26,58,3,-1,12">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::AutoWait::GO_TO_IDLE}-->
     <tran trig="GO_TO_IDLE" target="../../1">
      <tran_glyph conn="26,54,3,3,-7,-18,23">
       <action box="4,-21,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="26,46,20,15">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::StepsStrategy}-->
    <state name="StepsStrategy">
     <entry brief="arm_timer">QTimeEvt_armX(&amp;me-&gt;timeEvt, 3 * BSP_TICKS_PER_SEC, 3 * BSP_TICKS_PER_SEC);</entry>
     <exit brief="disarm_timer">QTimeEvt_disarm(&amp;me-&gt;timeEvt);
QTimeEvt_disarm(&amp;me-&gt;timeEvt_2);</exit>
     <!--${AOs::SumoHSM::SM::StepsStrategy::LINE_DETECTED}-->
     <tran trig="LINE_DETECTED" target="../../6">
      <tran_glyph conn="57,83,3,0,-3,24">
       <action box="0,-1,14,3"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StepsStrategy::TIMEOUT}-->
     <tran trig="TIMEOUT">
      <action>BSP_motors(100,100);
QTimeEvt_armX(&amp;me-&gt;timeEvt_2, BSP_TICKS_PER_MILISSEC * 100, 0);</action>
      <tran_glyph conn="57,78,3,-1,8">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StepsStrategy::TIMEOUT_2}-->
     <tran trig="TIMEOUT_2">
      <action>BSP_motors(0,0);</action>
      <tran_glyph conn="57,81,3,-1,11">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StepsStrategy::STOP_AUTO}-->
     <tran trig="STOP_AUTO" target="../../4">
      <tran_glyph conn="70,69,0,1,-14,-24">
       <action box="-22,-16,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StepsStrategy::DIST_SENSOR_CHANGE}-->
     <tran trig="DIST_SENSOR_CHANGE">
      <action brief="CheckSensors">int sensors_on = BSP_Check_Dist();
QTimeEvt_disarm(&amp;me-&gt;timeEvt);
QTimeEvt_disarm(&amp;me-&gt;timeEvt_2);

switch(sensors_on){
    case 0:
        BSP_motors(0,0);
        QTimeEvt_armX(&amp;me-&gt;timeEvt, 3 * BSP_TICKS_PER_SEC, 3 * BSP_TICKS_PER_SEC);
        break;
    case 1:
        BSP_motors(80,-80);
        break;
    case 2:
        BSP_motors(80,0);
        break;
    case 3:
        BSP_motors(100,100);
        break;
    case 4:
        BSP_motors(0,80);
        break;
    case 5:
        BSP_motors(-80,80);
        break;
}
</action>
      <tran_glyph conn="57,87,3,-1,14">
       <action box="0,-2,21,5"/>
      </tran_glyph>
     </tran>
     <state_glyph node="57,69,24,28">
      <entry box="1,2,19,2"/>
      <exit box="1,4,19,2"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::LineGoBack}-->
    <state name="LineGoBack">
     <entry brief="go_back">BSP_motors(-100,-100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * 250, 0);</entry>
     <!--${AOs::SumoHSM::SM::LineGoBack::TIMEOUT}-->
     <tran trig="TIMEOUT" target="../1">
      <tran_glyph conn="39,115,3,0,8,3">
       <action box="0,-3,16,4"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::LineGoBack::LineTurn}-->
     <state name="LineTurn">
      <entry brief="turn">BSP_motors(-100,100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * me-&gt;turn_180_time_ms * (0.6), 0);</entry>
      <exit>BSP_motors(0,0);</exit>
      <!--${AOs::SumoHSM::SM::LineGoBack::LineTurn::TIMEOUT}-->
      <tran trig="TIMEOUT">
       <!--${AOs::SumoHSM::SM::LineGoBack::LineTurn::TIMEOUT::[strategy_0]}-->
       <choice target="../../../../3">
        <guard brief="strategy_0">me-&gt;strategy == 0</guard>
        <choice_glyph conn="60,105,5,2,-25,-8">
         <action box="-25,-5,11,2"/>
        </choice_glyph>
       </choice>
       <!--${AOs::SumoHSM::SM::LineGoBack::LineTurn::TIMEOUT::[strategy_1]}-->
       <choice target="../../../../5">
        <guard brief="strategy_1">me-&gt;strategy == 1</guard>
        <choice_glyph conn="60,105,5,2,10,-8">
         <action box="1,-5,10,3"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="41,127,3,-1,19,-22">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="41,118,13,11">
       <entry box="1,2,8,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="39,107,18,24">
      <entry box="1,2,11,3"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::CalibTurn}-->
    <state name="CalibTurn">
     <entry>QTimeEvt_armX(&amp;me-&gt;timeEvt_2, 0xFFFFFFFF, 0);
BSP_motors(me-&gt;star_velocity, me-&gt;star_velocity);</entry>
     <!--${AOs::SumoHSM::SM::CalibTurn::LINE_DETECTED}-->
     <tran trig="LINE_DETECTED" target="../1">
      <action>if (me-&gt;calib_status == 0){
    me-&gt;calib_time_1 = 0xFFFFFFFF - QTimeEvt_currCtr(&amp;me-&gt;timeEvt_2);
} else {
    me-&gt;calib_time_2 = 0xFFFFFFFF - QTimeEvt_currCtr(&amp;me-&gt;timeEvt_2);
}</action>
      <tran_glyph conn="171,67,3,0,20,2">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack}-->
     <state name="CalibLineGoBack">
      <entry>BSP_motors(-100,-100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * 250, 0);</entry>
      <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack::TIMEOUT}-->
      <tran trig="TIMEOUT" target="../1">
       <tran_glyph conn="185,77,3,3,10">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack::CalibeLineTurn}-->
      <state name="CalibeLineTurn">
       <entry brief="turn">BSP_motors(-100,100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * me-&gt;turn_180_time_ms, 0);</entry>
       <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack::CalibeLineTurn::TIMEOUT}-->
       <tran trig="TIMEOUT">
        <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack::CalibeLineTurn::TIMEOUT::[calib_0]}-->
        <choice target="../../../..">
         <guard brief="calib_0">me-&gt;calib_status == 0</guard>
         <action brief="update_calib_status">me-&gt;calib_status++;
QTimeEvt_rearm(&amp;me-&gt;timeEvt_2, 0xFFFFFFFF);
BSP_motors(60,60);
</action>
         <choice_glyph conn="180,80,4,3,-1,-9">
          <action box="-9,-6,14,4"/>
         </choice_glyph>
        </choice>
        <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack::CalibeLineTurn::TIMEOUT::[calib_1]}-->
        <choice target="../../../../../8">
         <guard brief="calib_1">me-&gt;calib_status != 0</guard>
         <action brief="calibrate_turn">QTimeEvt_disarm(&amp;me-&gt;timeEvt_2);

uint8_t angle_diff;
if (me-&gt;calib_time_2 &gt; me-&gt;calib_time_1){
    angle_diff = 0;
} else {
    angle_diff = ((180 / M_PI) * acos((me-&gt;calib_time_2) / (double) me-&gt;calib_time_1));
}

if (me-&gt;strategy == 0) {
    me-&gt;turn_180_time_ms += angle_diff * CALIB_ANGLE_MULT;
} else {
    me-&gt;turn_180_time_ms -= angle_diff * CALIB_ANGLE_MULT;
}

</action>
         <choice_glyph conn="180,80,4,3,3,-15,-37,36">
          <action box="-20,4,10,5"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="195,80,3,-1,-15">
         <action box="-10,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="195,73,13,10">
        <entry box="1,2,8,2"/>
       </state_glyph>
      </state>
      <state_glyph node="185,69,28,17">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="171,57,43,35">
      <entry box="1,2,41,7"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::CalibWait}-->
    <state name="CalibWait">
     <entry>BSP_motors(0,0);
me-&gt;calib_status = 0;</entry>
     <!--${AOs::SumoHSM::SM::CalibWait::START_CALIB}-->
     <tran trig="START_CALIB">
      <!--${AOs::SumoHSM::SM::CalibWait::START_CALIB::[strategy_0||strategy_1]}-->
      <choice target="../../../7">
       <guard brief="strategy_0 || strategy_1">me-&gt;strategy == 0 || me-&gt;strategy == 1</guard>
       <choice_glyph conn="214,52,5,0,-21,5">
        <action box="-20,0,19,3"/>
       </choice_glyph>
      </choice>
      <!--${AOs::SumoHSM::SM::CalibWait::START_CALIB::[strategy_2]}-->
      <choice target="../../../9">
       <guard brief="strategy_2">me-&gt;strategy == 2</guard>
       <choice_glyph conn="214,52,5,0,29,4">
        <action box="7,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="214,49,2,-1,3">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::CalibWait::GO_TO_IDLE}-->
     <tran trig="GO_TO_IDLE" target="../../1">
      <tran_glyph conn="206,37,0,1,-8,-121">
       <action box="-117,-11,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="201,37,26,12">
      <entry box="1,2,20,7"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::CalibFront}-->
    <state name="CalibFront">
     <entry>QTimeEvt_armX(&amp;me-&gt;timeEvt_2, 0xFFFFFFFF, 0);
BSP_motors(me-&gt;star_velocity, me-&gt;star_velocity);</entry>
     <!--${AOs::SumoHSM::SM::CalibFront::LINE_DETECTED}-->
     <tran trig="LINE_DETECTED" target="../1">
      <action>uint32_t time_until_line = 0xFFFFFFFF - QTimeEvt_currCtr(&amp;me-&gt;timeEvt_2);

int16_t diff_to_reference = time_until_line - 285;

me-&gt;star_velocity += (diff_to_reference / 5);

</action>
      <tran_glyph conn="225,67,3,0,21,2">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::CalibFront::CalibFrontGoBack}-->
     <state name="CalibFrontGoBack">
      <entry>BSP_motors(-100,-100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * 250, 0);</entry>
      <!--${AOs::SumoHSM::SM::CalibFront::CalibFrontGoBack::TIMEOUT}-->
      <tran trig="TIMEOUT" target="../1">
       <tran_glyph conn="234,77,3,3,9">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <!--${AOs::SumoHSM::SM::CalibFront::CalibFrontGoBack::CalibeFrontTurn}-->
      <state name="CalibeFrontTurn">
       <entry brief="turn">BSP_motors(-100,100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * me-&gt;turn_180_time_ms, 0);</entry>
       <!--${AOs::SumoHSM::SM::CalibFront::CalibFrontGoBack::CalibeFrontTurn::TIMEOUT}-->
       <tran trig="TIMEOUT" target="../../../../8">
        <action>QTimeEvt_disarm(&amp;me-&gt;timeEvt_2);</action>
        <tran_glyph conn="256,78,1,1,11,-36,-40">
         <action box="-28,-39,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="243,74,13,10">
        <entry box="1,2,8,2"/>
       </state_glyph>
      </state>
      <state_glyph node="234,69,24,17">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="225,56,35,33">
      <entry box="1,2,29,6"/>
     </state_glyph>
    </state>
    <state_diagram size="271,181"/>
   </statechart>
  </class>
  <!--${AOs::SumoHSM_ctor}-->
  <operation name="SumoHSM_ctor" type="void" visibility="0x00" properties="0x01">
   <documentation>The Blinky &quot;constructor&quot; is provided outside of the Blinky class, so that it can be used independently from the class. This is part of the &quot;opaque pointer&quot; design idiom.</documentation>
   <code>SumoHSM *me = (SumoHSM *)AO_SumoHSM;
QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;SumoHSM_initial));
QTimeEvt_ctorX(&amp;me-&gt;timeEvt, &amp;me-&gt;super, TIMEOUT_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;timeEvt_2, &amp;me-&gt;super, TIMEOUT_2_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;buzzerTimeEvt, &amp;me-&gt;super, PLAY_BUZZER_SIG, 0U);
me-&gt;strategy = 0;
me-&gt;calib_time_1 = 0;
me-&gt;calib_time_2 = 0;
me-&gt;calib_status = 0;
me-&gt;turn_180_time_ms = 800;
me-&gt;star_velocity = 60;</code>
  </operation>
 </package>
 <!--${.}-->
 <directory name=".">
  <!--${.::src}-->
  <directory name="src">
   <!--${.::src::sumo_hsm.c}-->
   <file name="sumo_hsm.c">
    <text>#include &lt;math.h&gt;
#include &quot;qpc.h&quot;    /* QP/C framework API */
#include &quot;bsp.h&quot;    /* Board Support Package interface */

#define CALIB_ANGLE_MULT    2.5
#define M_PI                3.14159265

/* ask QM to declare the Blinky class --------------------------------------*/
$declare${AOs::SumoHSM}

/* instantiate the Blinky active object ------------------------------------*/
static SumoHSM l_sumo_hsm;
QActive * const AO_SumoHSM = &amp;l_sumo_hsm.super;

/* ask QM to define the Blinky class ---------------------------------------*/
$define${AOs::SumoHSM_ctor}
$define${AOs::SumoHSM}

#ifdef Q_SPY

void sumoHSM_update_qs_dict(){

    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.timeEvt);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.timeEvt_2);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.buzzerTimeEvt);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.strategy);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.calib_time_1);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.calib_time_2);

    QS_SIG_DICTIONARY(TIMEOUT_SIG,     (void *)0);
    QS_SIG_DICTIONARY(TIMEOUT_2_SIG, (void *)0);
    QS_SIG_DICTIONARY(PLAY_BUZZER_SIG,    (void *)0);
    QS_SIG_DICTIONARY(START_RC_SIG,  (void *)0);
    QS_SIG_DICTIONARY(START_AUTO_SIG,  (void *)0);
    QS_SIG_DICTIONARY(START_CALIB_SIG,  (void *)0);
    QS_SIG_DICTIONARY(GO_TO_IDLE_SIG,  (void *)0);
    QS_SIG_DICTIONARY(STOP_AUTO_SIG,  (void *)0);
    QS_SIG_DICTIONARY(LINE_DETECTED_SIG,  (void *)0);
    QS_SIG_DICTIONARY(DIST_SENSOR_CHANGE_SIG,  (void *)0);
    QS_SIG_DICTIONARY(RADIO_DATA_SIG,  (void *)0);


}

#endif</text>
   </file>
   <!--${.::src::main.c}-->
   <file name="main.c">
    <text>#include &quot;qpc.h&quot;    /* QP/C framework API */
#include &quot;bsp.h&quot;    /* Board Support Package interface */

Q_DEFINE_THIS_FILE

/* the main function -------------------------------------------------------*/
int main() {
    static QEvt const *sumoHSM_queueSto[10]; /* event queue buffer for SumoHSM */

    QF_init();  /* initialize the framework */
    BSP_init(); /* initialize the BSP */

    /* instantiate and start the SumoHSM active object */
    SumoHSM_ctor(); /* in C you must explicitly call the SumoHSM constructor */
    
    #ifdef Q_SPY
    sumoHSM_update_qs_dict();
    #endif

    QACTIVE_START(AO_SumoHSM, /* active object to start */
        1U,                  /* priority of the active object */
        sumoHSM_queueSto,     /* event queue buffer */
        Q_DIM(sumoHSM_queueSto), /* the length of the buffer */
        (void *)0, 0U,       /* private stack (not used) */
        (QEvt *)0);          /* initialization event (not used) */

    return QF_run(); /* let the framework run the application */
}</text>
   </file>
  </directory>
  <!--${.::inc}-->
  <directory name="inc">
   <!--${.::inc::bsp.h}-->
   <file name="bsp.h">
    <text>#ifndef BSP_H
#define BSP_H

/* a very simple Board Support Package (BSP) -------------------------------*/
enum { 
    BSP_TICKS_PER_SEC = 100
}; /* number of clock ticks in a second */

#define BSP_TICKS_PER_MILISSEC (BSP_TICKS_PER_SEC/1000.0)

void BSP_init(void);
void BSP_ledOff(void);
void BSP_ledOn(void);
void BSP_ledToggle(void);
void BSP_motors(int vel_esq, int vel_dir);
void BSP_ledStrip(int num, int stat);
void BSP_buzzer_beep(void);
void BSP_startRC(void);
void BSP_startAuto(void);
int BSP_Check_Dist(void);

/* define the event signals used in the application ------------------------*/
enum SumoHSMSignals {
    TIMEOUT_SIG = Q_USER_SIG, /* offset the first signal by Q_USER_SIG */
    TIMEOUT_2_SIG,
    PLAY_BUZZER_SIG,
    START_RC_SIG,
    START_AUTO_SIG,
    START_CALIB_SIG,
    GO_TO_IDLE_SIG,
    STOP_AUTO_SIG,
    LINE_DETECTED_SIG,
    DIST_SENSOR_CHANGE_SIG,
    RADIO_DATA_SIG,
    MAX_SIG, /* keep last (the number of signals) */
};

/* active object(s) used in this application -------------------------------*/
extern QActive * const AO_SumoHSM; /* opaque pointer to the SumoHSM AO */
$declare${AOs::SumoHSM_ctor}

#ifdef Q_SPY
void sumoHSM_update_qs_dict(void);
#endif

#endif /* BSP_H */</text>
   </file>
  </directory>
 </directory>
</model>
