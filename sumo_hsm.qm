<?xml version="1.0" encoding="UTF-8"?>
<model version="5.2.1" links="1">
 <!--${qpc}-->
 <framework name="qpc"/>
 <!--${AOs}-->
 <package name="AOs" stereotype="0x02">
  <!--${AOs::SumoHSM}-->
  <class name="SumoHSM" superclass="qpc::QMActive">
   <!--${AOs::SumoHSM::timeEvt}-->
   <attribute name="timeEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::buzzerTimeEvt}-->
   <attribute name="buzzerTimeEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::buzzerCount}-->
   <attribute name="buzzerCount" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::strategy}-->
   <attribute name="strategy" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::timeEvt_2}-->
   <attribute name="timeEvt_2" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::calib_time_1}-->
   <attribute name="calib_time_1" type="uint32_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::calib_time_2}-->
   <attribute name="calib_time_2" type="uint32_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::calib_status}-->
   <attribute name="calib_status" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::turn_180_time_ms}-->
   <attribute name="turn_180_time_ms" type="uint16_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::star_velocity}-->
   <attribute name="star_velocity" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::SumoHSM::SM}-->
   <statechart properties="0x03">
    <!--${AOs::SumoHSM::SM::initial}-->
    <initial target="../1">
     <action>(void)par; /* unused parameter */
/* arm the private time event to expire in 1/2s
* and periodically every 1/2 second
*/
QTimeEvt_armX(&amp;me-&gt;buzzerTimeEvt, BSP_TICKS_PER_SEC/10, 0);

me-&gt;buzzerCount = 0U;</action>
     <initial_glyph conn="72,7,5,1,21,6,-8">
      <action box="0,-2,7,2"/>
     </initial_glyph>
    </initial>
    <!--${AOs::SumoHSM::SM::Idle}-->
    <state name="Idle">
     <entry>BSP_ledOff();
BSP_motors(0,0);
me-&gt;strategy = 0;
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_SEC/2, BSP_TICKS_PER_SEC/2);</entry>
     <exit>QTimeEvt_disarm(&amp;me-&gt;timeEvt);
QTimeEvt_disarm(&amp;me-&gt;buzzerTimeEvt);</exit>
     <!--${AOs::SumoHSM::SM::Idle::TIMEOUT}-->
     <tran trig="TIMEOUT">
      <action>BSP_ledToggle();</action>
      <tran_glyph conn="42,30,3,-1,14">
       <action box="0,-2,14,4"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::Idle::RADIO_EVT_1}-->
     <tran trig="RADIO_EVT_1" target="../../4">
      <tran_glyph conn="42,41,3,3,-19,14,3">
       <action box="-16,-3,18,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::Idle::PLAY_BUZZER}-->
     <tran trig="PLAY_BUZZER">
      <action>BSP_buzzerBeep();

if (me-&gt;buzzerCount == 15) {
    QTimeEvt_armX(&amp;me-&gt;buzzerTimeEvt, 1.6 * BSP_TICKS_PER_SEC, 0);
    BSP_ledStripe(me-&gt;buzzerCount, 0x94, 0x00, 0xD3);
} else if (me-&gt;buzzerCount &lt; 15){
    QTimeEvt_armX(&amp;me-&gt;buzzerTimeEvt, BSP_TICKS_PER_SEC/10, 0);
    BSP_ledStripe(me-&gt;buzzerCount, 0x94, 0x00, 0xD3);
}


me-&gt;buzzerCount += 1;</action>
      <tran_glyph conn="42,34,3,-1,14">
       <action box="0,-2,12,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="42,11,43,33">
      <entry box="1,2,24,6"/>
      <exit box="1,8,38,7"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::RCWait}-->
    <state name="RCWait">
     <entry>BSP_ledOff();
BSP_ledStripeSetStrategyColor(me-&gt;strategy);
BSP_motors(0,0);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_SEC/10, BSP_TICKS_PER_SEC/10);</entry>
     <exit brief="StopTimer">QTimeEvt_disarm(&amp;me-&gt;timeEvt);</exit>
     <!--${AOs::SumoHSM::SM::RCWait::START}-->
     <tran trig="START" target="../../9">
      <tran_glyph conn="118,65,3,3,-7,16,6">
       <action box="-7,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::RCWait::RADIO_EVT_1}-->
     <tran trig="RADIO_EVT_1" target="../../7">
      <tran_glyph conn="138,55,1,3,63">
       <action box="0,-2,18,3"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::RCWait::TIMEOUT}-->
     <tran trig="TIMEOUT">
      <action>BSP_ledToggle();</action>
      <tran_glyph conn="118,63,3,-1,12,-1">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::RCWait::RADIO_EVT_2}-->
     <tran trig="RADIO_EVT_2">
      <action brief="Update Strategy">SumoHSM_change_strategy(me);
BSP_ledStripeSetStrategyColor(me-&gt;strategy);</action>
      <tran_glyph conn="118,66,3,-1,12">
       <action box="0,-2,20,4"/>
      </tran_glyph>
     </tran>
     <state_glyph node="118,52,20,18">
      <entry box="1,2,14,4"/>
      <exit box="1,6,14,2"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::StarStrategy}-->
    <state name="StarStrategy">
     <entry>BSP_motors(me-&gt;star_velocity, me-&gt;star_velocity);</entry>
     <!--${AOs::SumoHSM::SM::StarStrategy::LINE_DETECTED}-->
     <tran trig="LINE_DETECTED" target="../../10">
      <tran_glyph conn="24,92,3,3,-8,28,5">
       <action box="0,-2,15,3"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StarStrategy::STOP}-->
     <tran trig="STOP" target="../../4">
      <tran_glyph conn="41,81,0,2,-17">
       <action box="1,-6,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StarStrategy::DIST_SENSOR_CHANGE}-->
     <tran trig="DIST_SENSOR_CHANGE">
      <action brief="CheckSensors">if (BSP_distSensorIsReading(DIST_SENSOR_R)) {
   BSP_motors(80,-80);
} else if (BSP_distSensorIsReading(DIST_SENSOR_FR)) {
   BSP_motors(80,0);
} else if (BSP_distSensorIsReading(DIST_SENSOR_F)) {
   BSP_motors(100,100);
} else if (BSP_distSensorIsReading(DIST_SENSOR_FL)) {
   BSP_motors(0,80);
} else if (BSP_distSensorIsReading(DIST_SENSOR_L)) {
   BSP_motors(-80,80);
} else {
   BSP_motors(60,60);
}</action>
      <tran_glyph conn="24,97,3,-1,20">
       <action box="0,-2,24,4"/>
      </tran_glyph>
     </tran>
     <state_glyph node="24,81,25,28">
      <entry box="1,2,23,6"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::AutoWait}-->
    <state name="AutoWait">
     <entry>BSP_motors(0,0);
BSP_ledOn();
BSP_ledStripeSetStrategyColor(me-&gt;strategy);</entry>
     <!--${AOs::SumoHSM::SM::AutoWait::START}-->
     <tran trig="START">
      <!--${AOs::SumoHSM::SM::AutoWait::START::[strategy_0]}-->
      <choice target="../../../3">
       <guard brief="strategy_0">me-&gt;strategy == 0</guard>
       <choice_glyph conn="38,61,4,0,20">
        <action box="-9,5,9,4"/>
       </choice_glyph>
      </choice>
      <!--${AOs::SumoHSM::SM::AutoWait::START::[strategy_1]}-->
      <choice target="../../../5">
       <guard brief="strategy_1">me-&gt;strategy == 1</guard>
       <choice_glyph conn="38,61,5,0,31,20">
        <action box="20,5,11,3"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="26,61,3,-1,12">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::AutoWait::RADIO_EVT_1}-->
     <tran trig="RADIO_EVT_1" target="../../2">
      <tran_glyph conn="46,53,1,3,2,2,70">
       <action box="0,-3,19,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::AutoWait::RADIO_EVT_2}-->
     <tran trig="RADIO_EVT_2">
      <action>SumoHSM_change_strategy(me);
BSP_ledStripeSetStrategyColor(me-&gt;strategy);</action>
      <tran_glyph conn="26,57,3,-1,11">
       <action box="0,-2,13,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="26,47,20,17">
      <entry box="1,2,17,5"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::StepsStrategy}-->
    <state name="StepsStrategy">
     <entry brief="arm_timer">QTimeEvt_armX(&amp;me-&gt;timeEvt, 3 * BSP_TICKS_PER_SEC, 3 * BSP_TICKS_PER_SEC);</entry>
     <exit brief="disarm_timer">QTimeEvt_disarm(&amp;me-&gt;timeEvt);
QTimeEvt_disarm(&amp;me-&gt;timeEvt_2);</exit>
     <!--${AOs::SumoHSM::SM::StepsStrategy::TIMEOUT}-->
     <tran trig="TIMEOUT">
      <action>BSP_motors(100,100);
QTimeEvt_armX(&amp;me-&gt;timeEvt_2, BSP_TICKS_PER_MILISSEC * 100, 0);</action>
      <tran_glyph conn="59,90,3,-1,8">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StepsStrategy::TIMEOUT_2}-->
     <tran trig="TIMEOUT_2">
      <action>BSP_motors(0,0);</action>
      <tran_glyph conn="59,93,3,-1,11">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StepsStrategy::STOP}-->
     <tran trig="STOP" target="../../4">
      <tran_glyph conn="72,81,0,1,-22,-26">
       <action box="-23,-25,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StepsStrategy::DIST_SENSOR_CHANGE}-->
     <tran trig="DIST_SENSOR_CHANGE">
      <action brief="CheckSensors">QTimeEvt_disarm(&amp;me-&gt;timeEvt);
QTimeEvt_disarm(&amp;me-&gt;timeEvt_2);

if (BSP_distSensorIsReading(DIST_SENSOR_R)) {
   BSP_motors(80,-80);
} else if (BSP_distSensorIsReading(DIST_SENSOR_FR)) {
   BSP_motors(80,0);
} else if (BSP_distSensorIsReading(DIST_SENSOR_F)) {
   BSP_motors(100,100);
} else if (BSP_distSensorIsReading(DIST_SENSOR_FL)) {
   BSP_motors(0,80);
} else if (BSP_distSensorIsReading(DIST_SENSOR_L)) {
   BSP_motors(-80,80);
} else {
   BSP_motors(0,0);
   QTimeEvt_armX(&amp;me-&gt;timeEvt, 3 * BSP_TICKS_PER_SEC, 3 * BSP_TICKS_PER_SEC);
}

</action>
      <tran_glyph conn="59,101,3,-1,16">
       <action box="0,-2,21,5"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::StepsStrategy::LINE_DETECTED}-->
     <tran trig="LINE_DETECTED" target="../../11">
      <tran_glyph conn="59,97,3,3,-1,26,3">
       <action box="0,-2,16,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="59,81,24,28">
      <entry box="1,2,19,2"/>
      <exit box="1,4,19,2"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::CalibTurn}-->
    <state name="CalibTurn">
     <entry>QTimeEvt_armX(&amp;me-&gt;timeEvt_2, 0xFFFFFFFF, 0);
BSP_motors(me-&gt;star_velocity, me-&gt;star_velocity);</entry>
     <!--${AOs::SumoHSM::SM::CalibTurn::LINE_DETECTED}-->
     <tran trig="LINE_DETECTED" target="../1">
      <action>if (me-&gt;calib_status == 0){
    me-&gt;calib_time_1 = 0xFFFFFFFF - QTimeEvt_currCtr(&amp;me-&gt;timeEvt_2);
} else {
    me-&gt;calib_time_2 = 0xFFFFFFFF - QTimeEvt_currCtr(&amp;me-&gt;timeEvt_2);
}</action>
      <tran_glyph conn="171,79,3,0,20,2">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack}-->
     <state name="CalibLineGoBack">
      <entry>BSP_motors(-100,-100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * 250, 0);</entry>
      <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack::TIMEOUT}-->
      <tran trig="TIMEOUT" target="../1">
       <tran_glyph conn="185,89,3,3,10">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack::CalibeLineTurn}-->
      <state name="CalibeLineTurn">
       <entry brief="turn">BSP_motors(-100,100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * me-&gt;turn_180_time_ms, 0);</entry>
       <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack::CalibeLineTurn::TIMEOUT}-->
       <tran trig="TIMEOUT">
        <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack::CalibeLineTurn::TIMEOUT::[calib_0]}-->
        <choice target="../../../..">
         <guard brief="calib_0">me-&gt;calib_status == 0</guard>
         <action brief="update_calib_status">me-&gt;calib_status++;
QTimeEvt_rearm(&amp;me-&gt;timeEvt_2, 0xFFFFFFFF);
BSP_motors(60,60);
</action>
         <choice_glyph conn="180,92,4,3,-1,-9">
          <action box="-9,-6,14,4"/>
         </choice_glyph>
        </choice>
        <!--${AOs::SumoHSM::SM::CalibTurn::CalibLineGoBack::CalibeLineTurn::TIMEOUT::[calib_1]}-->
        <choice target="../../../../../7">
         <guard brief="calib_1">me-&gt;calib_status != 0</guard>
         <action brief="calibrate_turn">QTimeEvt_disarm(&amp;me-&gt;timeEvt_2);

uint8_t angle_diff;
if (me-&gt;calib_time_2 &gt; me-&gt;calib_time_1){
    angle_diff = 0;
} else {
    angle_diff = ((180 / M_PI) * acos((me-&gt;calib_time_2) / (double) me-&gt;calib_time_1));
}

if (me-&gt;strategy == 0) {
    me-&gt;turn_180_time_ms += angle_diff * CALIB_ANGLE_MULT;
} else {
    me-&gt;turn_180_time_ms -= angle_diff * CALIB_ANGLE_MULT;
}

</action>
         <choice_glyph conn="180,92,4,3,3,-15,-37,36">
          <action box="-20,4,10,5"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="195,92,3,-1,-15">
         <action box="-10,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="195,85,13,10">
        <entry box="1,2,8,2"/>
       </state_glyph>
      </state>
      <state_glyph node="185,81,28,17">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="171,69,43,35">
      <entry box="1,2,41,7"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::CalibWait}-->
    <state name="CalibWait">
     <entry>BSP_ledOn();
BSP_motors(0,0);
BSP_ledStripeSetStrategyColor(me-&gt;strategy);
me-&gt;calib_status = 0;
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * 250, 0);</entry>
     <exit brief="StopTimer">QTimeEvt_disarm(&amp;me-&gt;timeEvt);</exit>
     <!--${AOs::SumoHSM::SM::CalibWait::START}-->
     <tran trig="START">
      <!--${AOs::SumoHSM::SM::CalibWait::START::[strategy_0||strategy_1]}-->
      <choice target="../../../6">
       <guard brief="strategy_0 || strategy_1">me-&gt;strategy == 0 || me-&gt;strategy == 1</guard>
       <choice_glyph conn="214,64,5,0,-21,5">
        <action box="-20,0,19,3"/>
       </choice_glyph>
      </choice>
      <!--${AOs::SumoHSM::SM::CalibWait::START::[strategy_2]}-->
      <choice target="../../../8">
       <guard brief="strategy_2">me-&gt;strategy == 2</guard>
       <choice_glyph conn="214,64,5,0,29,4">
        <action box="7,0,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="214,61,2,-1,3">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::CalibWait::RADIO_EVT_1}-->
     <tran trig="RADIO_EVT_1" target="../../1">
      <action>BSP_ledStripeSetAll(0x94, 0x00, 0xD3);</action>
      <tran_glyph conn="203,46,0,1,-17,-118">
       <action box="-115,-20,17,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::CalibWait::TIMEOUT}-->
     <tran trig="TIMEOUT">
      <action>static bool time_long;

BSP_ledToggle();

if (time_long){
    QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * 150, 0);
} else {
    QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * 1000, 0);
}
time_long = !time_long;

</action>
      <tran_glyph conn="201,54,3,-1,12">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::CalibWait::RADIO_EVT_2}-->
     <tran trig="RADIO_EVT_2">
      <action>SumoHSM_change_strategy(me);
BSP_ledStripeSetStrategyColor(me-&gt;strategy);</action>
      <tran_glyph conn="201,57,3,-1,12">
       <action box="0,-2,12,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="201,46,26,15">
      <entry box="1,2,12,2"/>
      <exit box="1,4,13,3"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::CalibFront}-->
    <state name="CalibFront">
     <entry>QTimeEvt_armX(&amp;me-&gt;timeEvt_2, 0xFFFFFFFF, 0);
BSP_motors(me-&gt;star_velocity, me-&gt;star_velocity);</entry>
     <!--${AOs::SumoHSM::SM::CalibFront::LINE_DETECTED}-->
     <tran trig="LINE_DETECTED" target="../1">
      <action>uint32_t time_until_line = 0xFFFFFFFF - QTimeEvt_currCtr(&amp;me-&gt;timeEvt_2);

int16_t diff_to_reference = time_until_line - 285;

me-&gt;star_velocity += (diff_to_reference / 5);

</action>
      <tran_glyph conn="225,79,3,0,21,2">
       <action box="0,-2,15,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::CalibFront::CalibFrontGoBack}-->
     <state name="CalibFrontGoBack">
      <entry>BSP_motors(-100,-100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * 250, 0);</entry>
      <!--${AOs::SumoHSM::SM::CalibFront::CalibFrontGoBack::TIMEOUT}-->
      <tran trig="TIMEOUT" target="../1">
       <tran_glyph conn="234,89,3,3,9">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <!--${AOs::SumoHSM::SM::CalibFront::CalibFrontGoBack::CalibeFrontTurn}-->
      <state name="CalibeFrontTurn">
       <entry brief="turn">BSP_motors(-100,100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * me-&gt;turn_180_time_ms, 0);</entry>
       <!--${AOs::SumoHSM::SM::CalibFront::CalibFrontGoBack::CalibeFrontTurn::TIMEOUT}-->
       <tran trig="TIMEOUT" target="../../../../7">
        <action>QTimeEvt_disarm(&amp;me-&gt;timeEvt_2);</action>
        <tran_glyph conn="256,90,1,1,11,-36,-40">
         <action box="-28,-39,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="243,86,13,10">
        <entry box="1,2,8,2"/>
       </state_glyph>
      </state>
      <state_glyph node="234,81,24,17">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="225,68,35,33">
      <entry box="1,2,29,6"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::RC}-->
    <state name="RC">
     <entry>BSP_ledOff();</entry>
     <!--${AOs::SumoHSM::SM::RC::RADIO_DATA}-->
     <tran trig="RADIO_DATA">
      <action>int coord_x = BSP_radioGetChannel(RADIO_CH1);
int coord_y = BSP_radioGetChannel(RADIO_CH2);

int mot1 = coord_y + coord_x;
int mot2 = coord_y - coord_x;

BSP_motors(mot1, mot2);</action>
      <tran_glyph conn="117,87,3,-1,11">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::SumoHSM::SM::RC::STOP}-->
     <tran trig="STOP" target="../../2">
      <tran_glyph conn="137,80,1,1,6,-15,-5">
       <action box="2,-18,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="117,77,20,15">
      <entry box="1,2,12,4"/>
     </state_glyph>
    </state>
    <!--${AOs::SumoHSM::SM::line1}-->
    <smstate name="line1" submachine="../12">
     <!--${AOs::SumoHSM::SM::line1::XP1}-->
     <xpseg xpref="../../12/0" target="../../3">
      <xpseg_glyph conn="42,115,0,2,-4,5,-2">
       <action box="1,0,10,2"/>
      </xpseg_glyph>
     </xpseg>
     <!--${AOs::SumoHSM::SM::line1::STOP}-->
     <xpseg xpref="../../12/1" target="../../4">
      <xpseg_glyph conn="45,121,1,1,7,-58,-6">
       <action box="1,0,10,2"/>
      </xpseg_glyph>
     </xpseg>
     <smstate_glyph node="21,115,24,12"/>
    </smstate>
    <!--${AOs::SumoHSM::SM::line2}-->
    <smstate name="line2" submachine="../12">
     <!--${AOs::SumoHSM::SM::line2::XP1}-->
     <xpseg xpref="../../12/0" target="../../5">
      <xpseg_glyph conn="82,115,0,2,-6">
       <action box="1,0,10,2"/>
      </xpseg_glyph>
     </xpseg>
     <!--${AOs::SumoHSM::SM::line2::STOP}-->
     <xpseg xpref="../../12/1" target="../../4">
      <xpseg_glyph conn="85,121,1,1,11,-65,-50">
       <action box="1,0,10,2"/>
      </xpseg_glyph>
     </xpseg>
     <smstate_glyph node="61,115,24,12"/>
    </smstate>
    <!--${AOs::SumoHSM::SM::LineSubmachine}-->
    <submachine name="LineSubmachine">
     <!--${AOs::SumoHSM::SM::LineSubmachine::XP-XP1}-->
     <xp name="XP1">
      <xp_glyph point="72,2,0">
       <name box="1,-2,10,2"/>
      </xp_glyph>
     </xp>
     <!--${AOs::SumoHSM::SM::LineSubmachine::XP-STOP}-->
     <xp name="STOP">
      <xp_glyph point="83,23,1">
       <name box="1,-2,10,2"/>
      </xp_glyph>
     </xp>
     <!--${AOs::SumoHSM::SM::LineSubmachine::initial}-->
     <initial target="../3">
      <initial_glyph conn="6,6,5,0,11,3">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <!--${AOs::SumoHSM::SM::LineSubmachine::LineGoBack}-->
     <state name="LineGoBack">
      <entry brief="go_back">BSP_motors(-100,-100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * 250, 0);</entry>
      <!--${AOs::SumoHSM::SM::LineSubmachine::LineGoBack::TIMEOUT}-->
      <tran trig="TIMEOUT" target="../2">
       <tran_glyph conn="7,19,3,0,10,2">
        <action box="0,-3,16,4"/>
       </tran_glyph>
      </tran>
      <!--${AOs::SumoHSM::SM::LineSubmachine::LineGoBack::STOP}-->
      <tran trig="STOP" target="../.." cpref="../../1">
       <tran_glyph conn="56,23,1,1,26">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <!--${AOs::SumoHSM::SM::LineSubmachine::LineGoBack::LineTurn}-->
      <state name="LineTurn">
       <entry brief="turn">BSP_motors(-100,100);
QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_MILISSEC * me-&gt;turn_180_time_ms * (0.6), 0);</entry>
       <exit>BSP_motors(0,0);</exit>
       <!--${AOs::SumoHSM::SM::LineSubmachine::LineGoBack::LineTurn::TIMEOUT}-->
       <tran trig="TIMEOUT" target="../../.." cpref="../../../0">
        <tran_glyph conn="11,33,3,0,61,-30">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <!--${AOs::SumoHSM::SM::LineSubmachine::LineGoBack::LineTurn::DIST_SENSOR_CHANGE}-->
       <tran trig="DIST_SENSOR_CHANGE" target="../../.." cpref="../../../0">
        <tran_glyph conn="11,37,3,0,61,-34">
         <action box="0,-2,23,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="11,21,26,22">
        <entry box="1,2,10,2"/>
        <exit box="1,4,18,4"/>
       </state_glyph>
      </state>
      <state_glyph node="7,9,49,36">
       <entry box="1,2,16,3"/>
      </state_glyph>
     </state>
     <submachine_diagram size="81,44"/>
    </submachine>
    <state_diagram size="271,181"/>
   </statechart>
  </class>
  <!--${AOs::SumoHSM_ctor}-->
  <operation name="SumoHSM_ctor" type="void" visibility="0x00" properties="0x01">
   <documentation>The Blinky &quot;constructor&quot; is provided outside of the Blinky class, so that it can be used independently from the class. This is part of the &quot;opaque pointer&quot; design idiom.</documentation>
   <code>SumoHSM *me = (SumoHSM *)AO_SumoHSM;
QMActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;SumoHSM_initial));
QTimeEvt_ctorX(&amp;me-&gt;timeEvt, &amp;me-&gt;super.super, TIMEOUT_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;timeEvt_2, &amp;me-&gt;super.super, TIMEOUT_2_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;buzzerTimeEvt, &amp;me-&gt;super.super, PLAY_BUZZER_SIG, 0U);
me-&gt;strategy = 0;
me-&gt;calib_time_1 = 0;
me-&gt;calib_time_2 = 0;
me-&gt;calib_status = 0;
me-&gt;turn_180_time_ms = 800;
me-&gt;star_velocity = 60;</code>
  </operation>
 </package>
 <!--${.}-->
 <directory name=".">
  <!--${.::src}-->
  <directory name="src">
   <!--${.::src::sumo_hsm.c}-->
   <file name="sumo_hsm.c">
    <text>#include &lt;math.h&gt;
#include &quot;qf_custom_defines.h&quot;
#include &quot;qpc.h&quot;    /* QP/C framework API */
#include &quot;bsp.h&quot;    /* Board Support Package interface */
#include &quot;bsp_led.h&quot;
#include &quot;bsp_motors.h&quot;
#include &quot;bsp_buzzer.h&quot;
#include &quot;bsp_radio.h&quot;
#include &quot;bsp_dist_sensors.h&quot;

#define CALIB_ANGLE_MULT    2.5
#ifndef M_PI
#define M_PI                3.14159265
#endif
/* ask QM to declare the Blinky class --------------------------------------*/
$declare${AOs::SumoHSM}

static void SumoHSM_change_strategy(SumoHSM * const me);

/* instantiate the Blinky active object ------------------------------------*/
static SumoHSM l_sumo_hsm;
QActive * const AO_SumoHSM = &amp;l_sumo_hsm.super.super;

/* ask QM to define the Blinky class ---------------------------------------*/
$define${AOs::SumoHSM_ctor}

static void SumoHSM_change_strategy(SumoHSM * const me) {
    me-&gt;strategy++;
    if (me-&gt;strategy &gt; 2){
        me-&gt;strategy = 0;
    }
}

$define${AOs::SumoHSM}

#ifdef Q_SPY

void sumoHSM_update_qs_dict(){

    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.timeEvt);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.timeEvt_2);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.buzzerTimeEvt);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.strategy);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.calib_time_1);
    QS_OBJ_DICTIONARY(&amp;l_sumo_hsm.calib_time_2);

    QS_SIG_DICTIONARY(TIMEOUT_SIG,     (void *)0);
    QS_SIG_DICTIONARY(TIMEOUT_2_SIG, (void *)0);
    QS_SIG_DICTIONARY(PLAY_BUZZER_SIG,    (void *)0);
    QS_SIG_DICTIONARY(START_SIG,  (void *)0);
    QS_SIG_DICTIONARY(RADIO_EVT_1_SIG,  (void *)0);
    QS_SIG_DICTIONARY(RADIO_EVT_2_SIG,  (void *)0);
    QS_SIG_DICTIONARY(STOP_SIG,  (void *)0);
    QS_SIG_DICTIONARY(LINE_DETECTED_SIG,  (void *)0);
    QS_SIG_DICTIONARY(DIST_SENSOR_CHANGE_SIG,  (void *)0);
    QS_SIG_DICTIONARY(RADIO_DATA_SIG,  (void *)0);


}

#endif</text>
   </file>
   <!--${.::src::main.c}-->
   <file name="main.c">
    <text>#include &quot;qpc.h&quot;    /* QP/C framework API */
#include &quot;bsp.h&quot;    /* Board Support Package interface */

Q_DEFINE_THIS_FILE

/* the main function -------------------------------------------------------*/
int main() {
    static QEvt const *sumoHSM_queueSto[10]; /* event queue buffer for SumoHSM */

    QF_init();  /* initialize the framework */
    BSP_init(); /* initialize the BSP */

    /* instantiate and start the SumoHSM active object */
    SumoHSM_ctor(); /* in C you must explicitly call the SumoHSM constructor */
    
    #ifdef Q_SPY
    sumoHSM_update_qs_dict();
    #endif

    QACTIVE_START(AO_SumoHSM, /* active object to start */
        1U,                  /* priority of the active object */
        sumoHSM_queueSto,     /* event queue buffer */
        Q_DIM(sumoHSM_queueSto), /* the length of the buffer */
        (void *)0, 0U,       /* private stack (not used) */
        (QEvt *)0);          /* initialization event (not used) */

    return QF_run(); /* let the framework run the application */
}</text>
   </file>
  </directory>
  <!--${.::inc}-->
  <directory name="inc">
   <!--${.::inc::bsp.h}-->
   <file name="bsp.h">
    <text>#ifndef BSP_H
#define BSP_H

/* a very simple Board Support Package (BSP) -------------------------------*/
enum { 
    BSP_TICKS_PER_SEC = 100
}; /* number of clock ticks in a second */

#define BSP_TICKS_PER_MILISSEC (BSP_TICKS_PER_SEC/1000.0)

void BSP_init(void);

/* define the event signals used in the application ------------------------*/
enum SumoHSMSignals {
    TIMEOUT_SIG = Q_USER_SIG, /* offset the first signal by Q_USER_SIG */
    TIMEOUT_2_SIG,
    PLAY_BUZZER_SIG,
    START_SIG,
    STOP_SIG,
    RADIO_EVT_1_SIG,
    RADIO_EVT_2_SIG,
    LINE_DETECTED_SIG,
    DIST_SENSOR_CHANGE_SIG,
    RADIO_DATA_SIG,
    MAX_SIG, /* keep last (the number of signals) */
};

/* active object(s) used in this application -------------------------------*/
extern QActive * const AO_SumoHSM; /* opaque pointer to the SumoHSM AO */
$declare${AOs::SumoHSM_ctor}

#ifdef Q_SPY
void sumoHSM_update_qs_dict(void);
#endif

#endif /* BSP_H */</text>
   </file>
  </directory>
 </directory>
</model>
